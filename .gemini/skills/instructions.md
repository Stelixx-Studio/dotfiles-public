# Project Instructions

<!-- 
üö® AUTO-GENERATED FILE - DO NOT EDIT MANUALLY üö®
This file is generated by the 'skt' CLI. 
Source: cli/src/features/instructions/utils/builder.ts
To modify rules, edit: .skt/rules.csv or .skt/shared/instructions/templates/
-->

<!-- Auto-generated from detected workspace -->
<!-- Framework: null -->
<!-- Language: javascript -->
<!-- Features:  -->
<!-- Stack:  -->

## Workspace Conventions
**Rule**: Respect the SKT workspace structure.
- **.agent/**: Public AI Interface. Keep instructions here for IDE compatibility.
- **.skt/**: Private CLI State. Internal scripts and shared resources reside in `.skt/shared/`.
- **No Root Pollution**: Do not create new top-level folders without explicit user request.
- **Relative Paths**: Always use paths relative to the project root (detected via .sktrc.json).

## Shell Compatibility
**Rule**: Commands must be Fish/Zsh compatible (Universal Shell Protocol).
- **No Heredocs**: NEVER use `cat <<EOF`. Use `printf "line1\nline2" > file` or `echo "line" > file`.
- **Inline Env**: Use `KEY=val cmd` instead of `export KEY=val`.
- **POSIX Redirects**: Use `> file 2>&1` instead of `&> file`.
- **No Subshells in Strings**: Avoid `echo "$(cmd)"`.

## üêö Fish Shell Detected (CRITICAL)

**Your user is running: fish, version 4.4.0**

Fish shell **DOES NOT support heredocs**. When generating terminal commands, you MUST follow these rules:

### ‚ùå NEVER Generate This (Will Fail):
```bash
cat <<EOF > file.txt
line 1
line 2
EOF
```
**Error**: `fish: Expected a string, but found a redirection`

### ‚úÖ ALWAYS Use These Patterns Instead:

**Option 1: printf (Preferred)**
```bash
printf "content\n" > file.txt
```

**Option 2: echo with newlines**
```bash
echo "line 1
line 2" > file.txt
```

**Option 3: Multiple appends**
```bash
echo "line 1" > file.txt
echo "line 2" >> file.txt
```

### Other Fish Shell Restrictions:

| ‚ùå Don't Use | ‚úÖ Use Instead | Why |
|--------------|----------------|-----|
| `export VAR=value` | `set -x VARIABLE value` | Fish uses different syntax |
| `&> file` | `> file.txt 2>&1` | Bash-only redirect |
| `cat <<EOF` | `printf "content\n" > file.txt` | Heredocs not supported |
| `$(cmd)` in strings | Store in variable first | Safer in Fish |

### üéØ Remember:
- **Test EVERY terminal command** for Fish compatibility before suggesting
- **Prefer printf** over cat/echo for multi-line content
- **Always use POSIX redirects** (`> file 2>&1` not `&>`)
- **Check twice** before using any bash-ism

This is **critical** - commands that work in bash/zsh will FAIL in Fish if they use incompatible syntax.

## Generated Files Protocol
**Rule**: NEVER edit files with "AUTO-GENERATED" header manually.
- **Source of Truth**: Find the source file referenced in the header and edit that instead.
- **Verification**: Run `skt sync` to apply changes.
# Core

### No Magic Values
**Rule**: Use constants instead of magic values

**Example**:

```typescript
// ‚úÖ Good
const MAX_RETRIES = 3
const TIMEOUT_MS = 5000

// ‚ùå Bad
if (retries > 3) { }
setTimeout(fn, 5000)
```

### Error Handling
**Rule**: Always handle errors explicitly

**Example**:

```typescript
// ‚úÖ Good
try {
  await fetchData()
} catch (error) {
  console.error('Failed to fetch:', error)
  throw new Error('Data fetch failed')
}

// ‚ùå Bad
await fetchData() // No error handling
```

## Performance

### Avoid Premature Optimization
**Rule**: Optimize only when needed, measure first

### Use Memoization Wisely
**Rule**: Only memoize expensive computations

**Example**:

```typescript
// ‚úÖ Good - expensive computation
const expensiveValue = useMemo(() => {
  return heavyComputation(data)
}, [data])

// ‚ùå Bad - simple computation
const sum = useMemo(() => a + b, [a, b])
```

## Security

### Environment Variables
**Rule**: Never commit secrets

**Example**:

```typescript
// ‚úÖ Good
const apiKey = process.env.API_KEY

// ‚ùå Bad
const apiKey = 'sk-1234567890'
```

### Input Validation
**Rule**: Always validate user input

**Example**:

```typescript
// ‚úÖ Good
const schema = z.object({
  email: z.string().email(),
  age: z.number().min(0).max(120)
})

const validated = schema.parse(input)
```

### No Secrets in Code
**Rule**: Never commit secrets - use .env.local

**Example**:
```bash
# .env.local
NEXT_PUBLIC_API_KEY=xxx
```

## Input Sanitization

### Sanitize User Input
**Rule**: Sanitize before using dangerouslySetInnerHTML

**Example**:
```typescript
import DOMPurify from 'dompurify'
const clean = DOMPurify.sanitize(html)
```

## Server-Side Validation

### Always Validate on Server
**Rule**: Always validate on server

**Example**:
```typescript
// Server Action
export async function createUser(data: FormData) {
  // Validate here
}
```

## CSRF Protection

### Use CSRF Tokens
**Rule**: Implement CSRF protection for forms

**Example**:
```
Use Next.js built-in CSRF protection
```

### Explicit Return Types
**Rule**: Always specify return types for functions

**Example**:

```typescript
// ‚ùå Bad
function calculate(a: number, b: number) {
  return a + b;
}

// ‚úÖ Good
function calculate(a: number, b: number): number {
  return a + b;
}
```

### Systemic Instruction Awareness
**Rule**: AI agents must treat instructions as "Executive Code" to follow, not just "Passive Documentation".

**Mandate**: 
1. For all tasks, verify against `.agent/instructions.md` BEFORE proposing a plan.
2. For Level 1 & 2 tasks (Infra, API, Auth), create or update a Research/Audit doc confirming compliance with relevant rules.
3. NEVER skip instruction verification for workflows that change code, plans, or documentation.

### CLI Command Usage
**Rule**: ALWAYS use direct `skt` commands. DO NOT use `pnpm exec skt`, `npm run skt`, or `yarn skt`.

**Example**:
- ‚úÖ `skt sync`
- ‚úÖ `skt plan "description"`
- ‚ùå `pnpm exec skt sync` 

### Use Semantic Elements
**Rule**: Use semantic HTML elements

**Example**:
```html
<article>
  <h1>Title</h1>
  <p>Content</p>
</article>
```

## ARIA

### ARIA Labels
**Rule**: Add ARIA labels for screen readers

**Example**:
```html
<button aria-label="Close menu">
  <IconX />
</button>
```

### Alt Text
**Rule**: Add alt text for all images

**Example**:
```html
<img src="logo.png" alt="Company logo" />
```

## Keyboard Navigation

### Keyboard Support
**Rule**: Ensure keyboard navigation works

**Example**:
```typescript
onKeyDown={(e) => e.key === 'Enter' && handleClick()}
```

## Color Contrast

### WCAG AA Compliance
**Rule**: Meet WCAG AA contrast ratio 4.5:1

**Example**:
```
Use color contrast checker tools
```

### Strict Mode
**Rule**: Enable all strict rules

**Example**:

```json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended"
  ],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error"
  }
}
```

## Common Rules

### No Any
**Rule**: Never use any type

**ESLint**: `@typescript-eslint/no-explicit-any: error`

### No Unused Vars
**Rule**: Remove unused variables

**ESLint**: `@typescript-eslint/no-unused-vars: error`

### Explicit Return Types
**Rule**: Specify return types for functions

**ESLint**: `@typescript-eslint/explicit-function-return-type: warn`

### Feature First
**Rule**: Organize by features, not by type

**Example**:

```
‚úÖ Good:
features/
  auth/
    components/
    hooks/
    utils/
  dashboard/
    components/
    hooks/

‚ùå Bad:
components/
  AuthForm.tsx
  Dashboard.tsx
hooks/
  useAuth.ts
  useDashboard.ts
```

### Kebab Case
**Rule**: Use kebab-case for file names

**Example**:

```
‚úÖ Good: user-profile.tsx, api-client.ts
‚ùå Bad: UserProfile.tsx, apiClient.ts
```

## Import Patterns

### Absolute Imports
**Rule**: Use absolute imports with @ alias

**Example**:

```typescript
// ‚úÖ Good
import { Button } from '@/components/ui/button'
import { useAuth } from '@/features/auth/hooks'

// ‚ùå Bad
import { Button } from '../../../components/ui/button'
```

## Commit Messages

### Conventional Commits
**Rule**: Use conventional commit format

**Example**:

```
feat(auth): add login form
fix(api): handle timeout errors
docs(readme): update installation steps
```

### Co-Located Tests
**Rule**: Place tests next to source files

**Example**:
```
user-profile.tsx
user-profile.test.tsx
```

### All Passing
**Rule**: Ensure all tests pass

**Example**:
```bash
pnpm test
```

### Minimum Coverage
**Rule**: Aim for 80%+ coverage on critical paths

**Example**:
```bash
pnpm test:coverage
```

### No Any Type
**Rule**: Never use `any` type - use `unknown` or proper types

**Example**:

```typescript
// ‚ùå Bad
function process(data: any) {
  return data.value;
}

// ‚úÖ Good
function process(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as { value: string }).value;
  }
  throw new Error('Invalid data');
}
```

### Type Keyword
**Rule**: Use `type` for unions/intersections, `interface` for object shapes

**Example**:

```typescript
// ‚úÖ Use type for unions
type Status = 'pending' | 'success' | 'error';

// ‚úÖ Use interface for objects
interface User {
  id: string;
  name: string;
}
```

## Type Assertions

### Safe Assertions
**Rule**: Use type guards instead of assertions when possible

**Example**:

```typescript
// ‚ùå Avoid assertions
const value = data as string;

// ‚úÖ Use type guards
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

if (isString(data)) {
  // TypeScript knows data is string here
  console.log(data.toUpperCase());
}
```

## Enums

### Const Enums
**Rule**: Use const enums for better tree-shaking

**Example**:

```typescript
// ‚úÖ Good
const enum Status {
  Pending = 'PENDING',
  Success = 'SUCCESS',
  Error = 'ERROR'
}

// Usage
const status: Status = Status.Pending;
```

### String Enums
**Rule**: Prefer string enums over numeric for better debugging

**Example**:

```typescript
// ‚úÖ Good - values are clear
enum LogLevel {
  Debug = 'DEBUG',
  Info = 'INFO',
  Error = 'ERROR'
}

// ‚ùå Avoid - numeric values unclear
enum LogLevel {
  Debug,
  Info,
  Error
}
```

## Import Patterns

### Type Imports
**Rule**: Use `import type` for type-only imports

**Example**:

```typescript
// ‚úÖ Good
import type { User } from './types';
import { fetchUser } from './api';

// ‚ùå Bad - imports value when only type needed
import { User } from './types';
```

### Import Order
**Rule**: Group imports: external ‚Üí internal ‚Üí types

**Example**:

```typescript
// ‚úÖ Good order
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import type { User } from '@/types';
```

## Common Patterns

### Utility Types
**Rule**: Use built-in utility types

**Example**:

```typescript
// ‚úÖ Use Partial for optional fields
type PartialUser = Partial<User>;

// ‚úÖ Use Pick for subset
type UserPreview = Pick<User, 'id' | 'name'>;

// ‚úÖ Use Omit to exclude fields
type UserWithoutPassword = Omit<User, 'password'>;
```

### Generic Constraints
**Rule**: Constrain generics when needed

**Example**:

```typescript
// ‚úÖ Good - constrained generic
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// Usage
const user = { id: '1', name: 'John' };
const name = getProperty(user, 'name'); // Type: string
```

### Discriminated Unions
**Rule**: Use discriminated unions for state management

**Example**:

```typescript
// ‚úÖ Good pattern
type LoadingState = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: User }
  | { status: 'error'; error: string };

function handleState(state: LoadingState) {
  switch (state.status) {
    case 'success':
      // TypeScript knows state.data exists
      return state.data;
    case 'error':
      // TypeScript knows state.error exists
      return state.error;
  }
}
```

## API Type Patterns

### Response Types
**Rule**: Define clear API response types

**Example**:

```typescript
// ‚úÖ Good - clear response structure
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

interface ApiError {
  error: string;
  code: string;
  details?: Record<string, string>;
}

type Result<T> = ApiResponse<T> | ApiError;
```

### Request Types
**Rule**: Type API request parameters

**Example**:

```typescript
// ‚úÖ Good - typed request
interface CreateUserRequest {
  name: string;
  email: string;
  role?: 'admin' | 'user';
}

async function createUser(data: CreateUserRequest): Promise<User> {
  // Implementation
}
```

## Best Practices

### Avoid Unnecessary Fallbacks
**Rule**: Don't use fallback values for required fields

**Example**:

```typescript
// ‚ùå Bad - hides missing data
const name = user?.name || 'Unknown';

// ‚úÖ Good - handle missing data explicitly
if (!user?.name) {
  throw new Error('User name is required');
}
const name = user.name;
```

### Strict Null Checks
**Rule**: Enable strictNullChecks in tsconfig.json

**Example**:

```json
{
  "compilerOptions": {
    "strictNullChecks": true,
    "strict": true
  }
}
```

---

# Other

### Risk Level Classification
**Rule**: Classify every task by Risk Level BEFORE starting:
- **Level 1 (High)**: Infrastructure. Requires Architecture Audit.
- **Level 2 (Medium)**: Logic/API/Auth/I18n. Requires Rule Compliance Audit.
- **Level 3 (Low)**: UI/Content. Passive rule loading.


### Rule Compliance Audit
**Rule**: For Level 1 & 2 tasks, you MUST list 3-5 critical rules and explain compliance in your plan.
**Why**: Ensures quality from start, preventing verification failure explosion.


### No Hardcoded Strings
**Rule**: PROHIBITED from using hardcoded strings in JSX.
**Requirement**: Use `m.key()` from `@repo/i18n` or local i18n helper.

---

# Styling

### Tailwind: Logic over Strings
**Rule**: NEVER use template literals for conditional classes (e.g. `btn ${active ? 'a' : 'b'}`).
**Requirement**: ALWAYS use `cn()` or `clsx()` for conditional logic.


### Design System First
**Rule**: Before any UI/Styling work, you MUST check `design-system/MASTER.md` or `tailwind.config.ts`.
**Requirement**: Explicitly list the design tokens (colors, spacing) you will use in your plan.

---

# Backend

### No Hardcoded API URLs
**Rule**: PROHIBITED from hardcoding `/api/v1/` in literals.
**Requirement**: Use `apiClient` with `API_CONFIG.ENDPOINTS` instead.

---

## CLI Tool Development

### Build Integrity
**Rule**: NEVER assume CLI code works without rebuilding.
- **Trigger**: Any modification to `cli/src` (or source folder)
- **Action**: Run build script (e.g., `npm run build`).
- **Reason**: Binaries run from `dist/` or `lib/`, not directly from `src/` (unless using ts-node/tsx, but production builds matter).

### Local Verification
**Rule**: Verify the binary, not just the code.
- **Action**: Run `./bin/cli.js --version` (or equivalent) to verify changes.
- **Check**: Ensure `which <cmd>` points to your local version if testing globally.

### Release Process
**Rule**: Use Changesets for versioning.
- **Trigger**: Feature completion.
- **Action**: `npx changeset add`
- **Content**: Clearly describe user-facing changes.
- **Reason**: Automates version bumping and changelog generation.